// I have an Amazon API Gateway GET method/resource that takes three paramters, email, start date, and end date
// this feeds into a Lambda integration request where the following script is used in the body mapping template to send through the paramters (all or any)

##  See http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html
##  This template will pass through all parameters including path, querystring, header, stage variables, and context through to the integration endpoint via the body/payload
#set($allParams = $input.params())
{
"body-json" : $input.json('$'),
"params" : {
#foreach($type in $allParams.keySet())
    #set($params = $allParams.get($type))
"$type" : {
    #foreach($paramName in $params.keySet())
    "$paramName" : "$util.escapeJavaScript($params.get($paramName))"
        #if($foreach.hasNext),#end
    #end
}
    #if($foreach.hasNext),#end
#end
},
"stage-variables" : {
#foreach($key in $stageVariables.keySet())
"$key" : "$util.escapeJavaScript($stageVariables.get($key))"
    #if($foreach.hasNext),#end
#end
}
}

/*  

	Node.js Labmda function that gets fed from API Gatewat integration request
	Notice the event.params and how it maps to the GET query string that was established in the GET resource of the API Gateway (not shown here)


 */

exports.handler = function(event, context, callback){ 

/*

    Both of the following methods work; the first one was recommended as the most up-to-date
 
*/

//Method 1
//var doc = require('dynamodb-doc');
//var dynamo = new doc.DynamoDB();
//Method 2
var AWS = require('aws-sdk');
var dynamo = new AWS.DynamoDB.DocumentClient();

/*
  console.log('Body:', event.body);
  console.log('Headers:', event.headers);
  console.log('Method:', event.method);
  console.log('Params:', event.params);
  console.log('Query:', event.query);
  console.log('parsed:', JSON.stringify(event));
  console.log('EMAIL :', event.params.querystring.email);
  console.log('STARTDATE :', event.params.querystring.startDate)
  console.log('ENDDATE :', event.params.querystring.endDate)
*/

/*  */

// TODO: check for missing required paramteres and return a sensible error

var email = event.params.querystring.email;
var startDate = parseInt((new Date(event.params.querystring.startDate).getTime() / 1000).toFixed(0));
var endDate = parseInt((new Date(event.params.querystring.endDate).getTime() / 1000).toFixed(0));

var params = {
    TableName: "DeliveredEvents",
    IndexName: "email-timestamp-index",
    ProjectionExpression: "email, #date, category, #emailResponse",
    KeyConditionExpression:"#email = :emailValue AND #date BETWEEN :startDate AND :endDate ",
    ExpressionAttributeNames: {
        "#email":"email",
        "#date":"timestamp",
        "#emailResponse" : "response"
        },
    ExpressionAttributeValues: {
        ":emailValue" : email,
        ":startDate" : startDate,
        ":endDate" : endDate
        }
    };

// TODO: Handle DynamoDB pagination

dynamo.query(params, function(err, data) {
    if (err) console.log(err); // an error occurred
    else console.log(data); // successful response
    
    
    //create new object to return processed results
    var newData = {
        
        "DeliveredEmailEvents" : [],
        "Count" : data.Count,
        "ScannedCount": data.ScannedCount
        
    };
    
    //get the items from the dynamo search results
    var items = data.Items;    
    
    
    //iterate through the results and convert unix timestamps to date/time string
    for (var j = 0; j < items.length; j++){
        
        var item = items[j];
        
        /*  */
        var d = new Date(item.timestamp * 1000);
        //played hell trying to inline the ternary operator
        var day = d.getDate().toString().length < 2 ? "0"+(d.getDate().toString()) : d.getDate().toString();
        var month = d.getMonth().toString().length < 2 ? "0"+(d.getMonth().toString()) : d.getMonth().toString();
        var hour =  d.getHours().toString().length < 2 ? "0"+(d.getHours().toString()) : d.getHours().toString();
        var minute = d.getMinutes().toString().length < 2 ? "0"+(d.getMinutes().toString()) : d.getMinutes().toString();
        var second = d.getSeconds().toString().length < 2 ? "0"+(d.getSeconds().toString()) : d.getSeconds().toString();
        
        
        // flatten out the categories a bit
        var categories = [];
        var category = item.category.values;
        
        for (var i = 0; i < item.category.values.length; i++){
                categories.push(category[i]);
        }
        
        newData.Items.push(
            {
                "category" : categories,
                "response" : item.response,
                "email" : item.email,
                "datetime" : d.getFullYear() + "-" + month +  "-" + day + " " + hour + ":" + minute + ":" + second
            }
        );
    }
    
    //return the processed results to the user 
    callback(null, newData);
});


}


